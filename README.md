
# 传输协议

&emsp;&emsp;网络协议是在主机与主机之间、主机与通信子网之间或同虚拟子网中各通信节点之间的通信而使用的，是通信双方必须遵守的，事先约定好的规则、标准或规定。

&emsp;&emsp;计算机网络的各个层次及其相关协议的集合称为网络体系结构。换句话说，网络体系结构是计算机网络所应完成的功能的精确定义。

## 1. OSI七层协议
> 开放系统互连参考模型（OSI）采用七层次体系结构

![alt 七层协议](https://img-blog.csdnimg.cn/20190105164025264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNjIy,size_16,color_FFFFFF,t_70)
> 
### 1.物理层
&emsp;&emsp;规定在一个节点内如何**把计算机连接到通信介质上**，该层负责简历、保持和拆除物理链路。在物理层数据传送单位是比特（bit）。
### 2. 数据链路层
&emsp;&emsp;数据链路层把**相邻**两个节点间不可靠的物理链路变成可靠、无差错的逻辑链路，具有把原始比特流进行分帧、排序、设置检错、确认、重发、流量控制等功能。数据链路层负责建立、维护和释放数据链路，具有差错控制、流量控制和线路规程的功能。传送信息的单位是帧（frame）。
### 3. 网络层
&emsp;&emsp;网络层连接网络中**任意**两个计算机节点，从一个节点接收数据并正确的传送到另一个节点。网络层的主要任务是选择合适的路由和交换节点，透明的向目的站交付发送炸所发的分组或包。传送信息单位是分组或包（packet）。

> &emsp;&emsp;上述三层组成了所谓的**通信子网**，用户计算机连接到通信子网上。通信子网负责把一个计算机上的数据**可靠地**传送到另一台计算机，但并未实现两台主机上进程之间的通信。通信子网的主要功能是面向通信的。
### 4. 传输层
&emsp;&emsp;传输层真正实现了“端到端”通信，把数据可靠地从一方的用户进程或程序送到另一方的用户进程或程序。这一层的控制同查那个由通信两端的计算机完成。中间节点一般不提供该层的服务，该层的通信与通信子网无关。从这层考试的以上各层全部是针对通信的最终“源端—目的端”计算机**进程**的。传送信息单位是报文（message）。

> &emsp;&emsp;传输层向上一层提供**可靠的**“端到端”服务，对上层透明，称为网络体系结构中**最关键**的一层。功能主要在**主机内**实现，物理层、数据链路层及网络层功能在**网络通信处理机**中实现。传输层以上各层次的功能通常在**主机**中实现。
### 5. 会话层
&emsp;&emsp;会话层允许两台计算机上的用户进程建立会话连接，双方相互确认身份，协商对话连接的细节。还提供同步点机制，网络出故障后可以仅重传最近一个同步点以后的数据。

> 输出层和会话层为两台计算机上的用户进程或程序之间提供了正确传送数据的手段。
### 6. 表示层
&emsp;&emsp;表示出主要解决用户信息的语法表示问题。表示层将数据从适合于某一系统的语法转变为适合于OSI系统内部使用的语法，即将用户传送的数据金星翻译或解释、编码和变换，使得机器相互理解。数据加密、解密、信息压缩都是本层的典型功能。
### 7. 应用层
&emsp;&emsp;应用层确定进程之间通信的性质，以满足用户的需要，即处理用户的数据和信息，由用户程序（应用程序）组成，完成用户所希望的师级人物。这层包括最终用户普遍需要的协议，如虚拟终端协议、文件传输协议、电子邮件协议等。

## 2. TCP和UDP
> 
### UDP（用户数据报协议）

> &emsp;&emsp;UDP **不提供可靠性**，UDP 检查和覆盖 UDP 报头和 UDP 数据。注意，IP 报头中的检查和值覆盖该 IP 报头，它不涉及 IP 数据报中的任何数据。UDP 和 TCP 均在其报头中有覆盖其报头和数据的检查和。对 UDP 而言，检查和是可选的，而 TCP 则是必需的。

> &emsp;&emsp;首先，UDP 数据报的长度可以是奇数个字节，而检查和算法是加 16 位字。解决办法是在尾部追加 0 的填充字节，而这填充字节仅为计算检查和所需。

> &emsp;&emsp;另外，UDP 和 TCP 均在报文中包含一个 12 字节的伪报头以计算检查和。该伪报头包含 IP 报头的某些域，目的是让 UDP 检测数据确已到达正确的目的端。

> &emsp;&emsp;如果发送者的确计算了检查和并且接收者检测出检查和错误，则该 UDP 数据报会被简单地丢弃，不产生错误信息。

> &emsp;&emsp;**UDP 不提供可靠性，为何还要使用 UDP？**

> &emsp;&emsp;我们知道 TC P就是为了解决 IP 层不可靠的传输层协议，既然 UDP 是不可靠的，为什么不直接使用 IP 协议而要额外增加一个 UDP 协议呢？
1. 一个重要的原因是 IP 协议中并没有端口(port)的概念。IP 协议进行的是 IP 地址到 IP 地址的传输，这意味者两台计算机之间的对话。但每台计算机中需要有多个通信通道，并将多个通信通道分配给不同的进程使用。一个端口就代表了这样的一个通信通道。UDP 协议实现了端口，从而让数据包可以在送到 IP 地址的基础上，进一步可以送到某个端口。
2. 对于一些简单的通信，我们只需要“Best Effort”式的 IP 传输就可以了，而不需要 TCP 协议复杂的建立连接的方式(特别是在早期网络环境中，如果过多的建立 TCP 连接，会造成很大的网络负担，而 UDP 协议可以相对快速的处理这些简单通信）
3. 在使用 TCP 协议传输数据时，如果一个数据段丢失或者接收端对某个数据段没有确认，发送端会重新发送该数据段。TCP 重新发送数据会带来传输延迟和重复数据，降低了用户的体验。对于迟延敏感的应用，少量的数据丢失一般可以被忽略，这时使用 UDP 传输将能够提升用户的体验。

> ### TCP（传输控制协议）
### 1. 网络传输的本质方式
&emsp;&emsp;网络传输的本质就是buffer的传输，它决定了序列化和反序列化的重要应用。
### 2. 三次握手
&emsp;&emsp;TCP 连接的过程叫做握手，握手需要在客户端和服务器之间交换三个TCP报文段来完成。
![alt 三次握手](https://img-blog.csdnimg.cn/20190402112938278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dqZDE5ODg=,size_16,color_FFFFFF,t_70)
1. A主机向B发送连接请求报文段，这是首部中的同部位SYN=1,同时选择一个初始序号seq=x,TCP规定，SYN报文段（即SYN=1的报文段）不能携带数据，但是需要消耗掉一个序号。A主机进入SYN-SENT（同步已发送）状态。

> 2. B主机收到请求报文后，如果同意建立连接，则向A发送确认报文。在确认报文段中应把SYN位和ACK位都置为1，确认号是ack=x+1，同时也为自己选择一个初始序列号seq=y。这时候主机B进入了SYN-RCVD(同步收到)状态。

> 3. A主机收到B主机发送的确认报文后，还要跟B主机确认，确认报文段的ACK置1，确认号ack=y+1,而自己的序号seq=x+1。A进入ESTABLISHED（已建立连接）状态。当B收到A的确认报文后，也进入ESTABLISHED状态。

> ### 3. 四次握手
&emsp;&emsp;TCP 连接的释放

> &emsp;&emsp;数据传输结束后，通信双方都可释放链接。现在A和B都处于ESTABLISHED状态。A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放文段首部的终止控制位FIN置为1，其序号seq=u,（它等于前面已传过的数据的最后一个字节的序号加1）这时A进入FIN-WAIT-1(终止等待1)状态，等待B的确认。
![alt 四次握手](https://img-blog.csdnimg.cn/20190403113930424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dqZDE5ODg=,size_16,color_FFFFFF,t_70)
&emsp;&emsp;B收到链接释放报文段后即发出确认，确认号是ack=u+1,而这个报文的序号是v，等于B前面已经传送过的数据的最后一个字节的序号加1。然后B进入了CLOSE-WAIT(关闭等待)状态。这时的TCP连接处于半关闭（HALF-CLOSE）状态。即，A已经没有数据要发送了，但是B有数据发送，A还是会接收。也就是说从B到A的连接并没有关闭，这个状态可能会持续一段时间。

> &emsp;&emsp;A收到B的确认后，就进入FIN-WAIT-2(终止-等待-2)状态，等待B发出连接释放的报文。

> &emsp;&emsp;若B已经没有要向A发送数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文必须使FIN=1。现假定B的序号为w（在半关闭状态B可能又发送了一些数据）。B还必须重复上次已发送过的确认好ack= u+1。这时B就进入LAST-ACK(最后确认)状态，等待A的确认。

> &emsp;&emsp;A收到B的连接释放报文段后，必须对此发出确认，在确认报文段中把ACK置为1，确认号ack=w+1,而自己的序号是seq=u+1。然后进入TIME-WAIT(时间等待)状态。请注意，现在的TCP连接还没有释放掉。必须经过时间等待计时器（TIME-WAIT timer）设置的时间2MSL后，A才进入到CLOSED状态。时间MSL叫做最长报文段寿命（Maximum Segment Lifetime）,通常是两分钟。因此，A进入到TIME-WAIT状态后，要经过4分钟才能进入到CLOSED状态，才能开始建立下一个新的连接。

## 3. http和https
### 1. http请求头
### 2. http响应头
### 3. http状态码
### 4. http1.0
### 5. http2.0


___
-----参考CSDN博客------

https://blog.csdn.net/gjd1988/article/details/88972042

-----图片源于网络-----


